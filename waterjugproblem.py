# -*- coding: utf-8 -*-
"""waterjugProblem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19QivFkWGiCUhysGZmylSu3TZYnkGkoVQ
"""



"""# **Using BFS**"""

from collections import deque

JUG1 = 4
JUG2 = 3
GOAL = 1

def water_jug_bfs():
    start = (0, 0)
    visited = set()
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                queue.append(new_path)
    return None

solution = water_jug_bfs()
print("BFS Solution path:")
for step in solution:
    print(step)

"""# **DFS**"""

def water_jug_dfs():
    start = (0, 0)
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                stack.append(new_path)
    return None

solution = water_jug_dfs()
print("DFS Solution path:")
for step in solution:
    print(step)

"""# Using A* **bold text**"""

import heapq

def heuristic(state):
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    start = (0, 0)
    open_list = []
    heapq.heappush(open_list, (heuristic(start), 0, [start]))
    visited = {}

    while open_list:
        f, g, path = heapq.heappop(open_list)
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited and visited[state] <= g:
            continue
        visited[state] = g

        x, y = state
        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited or g + 1 < visited.get(nxt, float('inf')):
                new_path = list(path)
                new_path.append(nxt)
                new_g = g + 1
                new_f = new_g + heuristic(nxt)
                heapq.heappush(open_list, (new_f, new_g, new_path))

solution = a_star_water_jug()
print("A* Solution path:")
for step in solution:
    print(step)

"""# 1) Compare the solution paths found by BFS, DFS, and A* **bold text**

BFS path (example): (0,0) → (4,0) → (1,3)  3 states, 2 actions.

DFS path (example): (0,0) → (0,3) → (3,0) → (3,3) → (4,2) → (4,0) → (1,3)  7 states, 6 actions.

A* path (example): (0,0) → (4,0) → (1,3) same as BFS in this run.

So BFS and A* returned the shorter path; DFS returned a longer (non-optimal) path in the shown run.

# 2) Which algorithm gives the shortest path? Why?**bold text**

Shortest path: BFS and A* (both produced the same shortest path here).

Why BFS: BFS explores the state space level by level (increasing number of actions). With uniform step cost (each action counted as 1), BFS is guaranteed to find a solution with the minimum number of steps (i.e., shortest path in terms of actions).

Why A* can be shortest: A* is optimal if the heuristic is admissible (never overestimates true remaining cost). In your implementation the heuristic min(|x-G|, |y-G|) is optimistic for this problem and therefore A* also finds an optimal (shortest) solution.

Why DFS is not shortest: DFS follows one branch deeply without considering path length, so it may find a solution that is longer (more actions) than the optimal.

# 3) Which algorithm is more efficient in time and memory?**bold text**

BFS, DFS, A* (Time & Memory)

BFS

Time: Finds shortest path but checks many states.

Memory: Uses a lot of memory.

Good when shortest path is must and memory is not a problem.

DFS

Time: Can be fast or very slow (not always shortest).

Memory: Uses very little memory.

Good when memory is small, but path may not be shortest.

A*

Time: Very efficient if heuristic is good.

Memory: Uses more memory than DFS but usually less than BFS.

Best balance → finds shortest path faster than BFS.
"""